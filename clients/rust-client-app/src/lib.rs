// src/lib.rs

// generated by wit-bindgen, from the host.wit (`package levo:portal; interface my-imports {}`)
use levo::portal::my_imports::*;

use rand::Rng;
use std::sync::{Mutex, OnceLock};

// Use a procedural macro to generate bindings for the world we specified in
// `host.wit`
wit_bindgen::generate!({
    path: "../../spec",
    // the name of the world in the `*.wit` input file
    world: "my-world",

    // For all exported worlds, interfaces, and resources, this specifies what
    // type they're corresponding to in this module. In this case the `MyHost`
    // struct defined below is going to define the exports of the `world`,
    // namely the `run` function.
    exports: {
        world: MyWorld,
    },
});

// Define a custom type and implement the generated `Guest` trait for it which
// represents implementing all the necessary exported interfaces for this
// component.
struct MyWorld;

struct Particle {
    x: f32,
    y: f32,
    speed: f32,
    radius: f32,
    color: String,
}

fn particles() -> &'static Mutex<Vec<Particle>> {
    static ARRAY: OnceLock<Mutex<Vec<Particle>>> = OnceLock::new();
    ARRAY.get_or_init(|| Mutex::new(vec![]))
}

fn tick() -> &'static Mutex<u32> {
    static TICK: OnceLock<Mutex<u32>> = OnceLock::new();
    TICK.get_or_init(|| Mutex::new(0))
}

fn heart_offset() -> &'static Mutex<(f32, f32)> {
    static TICK: OnceLock<Mutex<(f32, f32)>> = OnceLock::new();
    TICK.get_or_init(|| Mutex::new((0., 0.)))
}

fn create_particles() {
    let canvas_width = canvas_size().width;
    let mut tick = tick().lock().unwrap();
    let mut particles = particles().lock().unwrap();
    *tick += 1;
    if *tick % 10 == 0 {
        if particles.len() < 100 {
            particles.push(Particle {
                x: if let Some(cursor_position) = mouse_button_pressed(MouseButton::Left)
                    .then_some(())
                    .and_then(|_| cursor_position())
                {
                    cursor_position.x
                } else {
                    rand::thread_rng().gen_range(0.0..canvas_width)
                },
                y: 0.,
                speed: 500. + rand::thread_rng().gen_range(0.0..1.0) * 13.,
                radius: 5. + rand::thread_rng().gen_range(0.0..1.0) * 5.,
                color: "white".to_string(),
            })
        }
    }
}

fn update_particles() {
    let mut particles = particles().lock().unwrap();
    for particle in particles.iter_mut() {
        particle.y -= particle.speed * delta_seconds();
    }
}

fn kill_particles() {
    let canvas_height = canvas_size().height;
    let mut particles = particles().lock().unwrap();
    for particle in particles.iter_mut() {
        if particle.y < -canvas_height {
            particle.y = 0.;
        }
    }
}

fn draw_particles() {
    let canvas_size = canvas_size();
    fill_style("royal_purple");
    fill_rect(0., 0., canvas_size.width, canvas_size.height);
    let mut particles = particles().lock().unwrap();
    for particle in particles.iter_mut() {
        begin_path();
        arc(
            particle.x,
            particle.y,
            particle.radius,
            2. * std::f32::consts::PI,
            0.,
        );
        close_path();
        fill_style(&particle.color);
        fill();
    }
}

fn draw_heart(x_offset: f32, y_offset: f32) {
    begin_path();
    move_to(x_offset, y_offset);
    cubic_bezier_to(
        70. + x_offset,
        70. + y_offset,
        175. + x_offset,
        -35. + y_offset,
        0. + x_offset,
        -140. + y_offset,
    );
    cubic_bezier_to(
        -175. + x_offset,
        -35. + y_offset,
        -70. + x_offset,
        70. + y_offset,
        0. + x_offset,
        0. + y_offset,
    );
    close_path();
    fill_style("red");
    fill();
}

impl Guest for MyWorld {
    fn update() {
        create_particles();
        update_particles();
        kill_particles();
        draw_particles();

        let tick = tick().lock().unwrap();
        if *tick > 100 {
            let mut heart_offset = heart_offset().lock().unwrap();
            let heart_speed = 222.;
            if key_pressed(KeyCode::Left) {
                heart_offset.0 = heart_offset.0 - heart_speed * delta_seconds();
            }

            if key_pressed(KeyCode::Right) {
                heart_offset.0 = heart_offset.0 + heart_speed * delta_seconds();
            }

            if key_pressed(KeyCode::Up) {
                heart_offset.1 = heart_offset.1 + heart_speed * delta_seconds();
            }

            if key_pressed(KeyCode::Down) {
                heart_offset.1 = heart_offset.1 - heart_speed * delta_seconds();
            }

            draw_heart(heart_offset.0, heart_offset.1);
        }
        if *tick > 200 {
            label("Happy New Year from Rust!", 0., -150., 64., "white");
            link("localhost/c.wasm", "Go to c.wasm", -100., -200., 32.);
        }
    }

    fn setup() {
        print("setup from guest (Rust) has been called");
    }
}
